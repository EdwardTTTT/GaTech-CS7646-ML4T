#This code is a re-submission of Summer 2024 work, which may contain previous code

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import datetime as dt
# from util import get_data
from util import get_data

def author():
    return 'gtai3'  # Replace with your GT username


def compute_portvals(trades_df, start_val=1000000):
    """
    Computes the portfolio values based on trades generated by a trading strategy.

    :param trades_df: DataFrame of trades with dates as index and symbols as columns
    :type trades_df: pd.DataFrame
    :param start_val: The starting value of the portfolio
    :type start_val: int
    :return: The result (portvals) as a single-column dataframe, containing the value of the portfolio for each trading day
    :rtype: pandas.DataFrame
    """
    # Extract start and end dates from the trades_df
    start_date = trades_df.index.min()
    end_date = trades_df.index.max()
    
    # Get the list of symbols from trades_df
    symbols = trades_df.columns.unique()
    
    # Fetch historical stock data for the symbols in trades_df
    dates = pd.date_range(start_date, end_date)
    prices_all = get_data(symbols, dates)  # Adjusted closing prices
    
    # Add 'Cash' column with value 1.0 for easier calculations
    prices_all['Cash'] = 1.0
    
    # Initialize the trades DataFrame
    trades = trades_df.copy()
    
    # Initialize holdings DataFrame
    holdings = trades.cumsum()
    holdings['Cash'] = start_val - (trades * prices_all).sum(axis=1).cumsum()
    
    # Calculate the portfolio value for each day
    portvals = (holdings * prices_all).sum(axis=1)
    
    # Create a single-column DataFrame for the portfolio values
    portvals = pd.DataFrame(portvals, columns=['Portfolio Value'])
    
    return portvals


def testPolicy(symbol="AAPL", sd=dt.datetime(2010, 1, 1), ed=dt.datetime(2011, 12, 31), sv=100000):
    """
    Implement Theoretically Optimal Strategy allowing trades up to 2000 shares,
    but restricting the final positions to +/-1000 shares.

    :param symbol: Stock symbol to act on
    :param sd: Start date of the simulation
    :param ed: End date of the simulation
    :param sv: Start value of the portfolio
    :return: DataFrame of trades
    """
    # Get historical stock data
    dates = pd.date_range(sd, ed)
    prices = get_data([symbol], dates, colname='Adj Close')

    # Initialize trade dataframe
    df_trades = pd.DataFrame(index=prices.index, columns=[symbol])
    df_trades = df_trades.fillna(0)  # Initialize all trades to zero

    position = 0  # Current position (start with 0 shares)

    # Determine optimal trades based on future price knowledge
    for i in range(prices.shape[0] - 1):
        # Buy if the next day's price is higher
        if prices.iloc[i + 1][symbol] > prices.iloc[i][symbol]:
            if position == -1000:
                df_trades.iloc[i] = 2000  # Close short, go long
            elif position == 0:
                df_trades.iloc[i] = 1000  # Open a long position
            position = 1000
        # Sell if the next day's price is lower
        elif prices.iloc[i + 1][symbol] < prices.iloc[i][symbol]:
            if position == 1000:
                df_trades.iloc[i] = -2000  # Close long, go short
            elif position == 0:
                df_trades.iloc[i] = -1000  # Open a short position
            position = -1000
        else:
            df_trades.iloc[i] = 0  # No trade, hold current position

    return df_trades

def plot_strategy(symbol, sd, ed, sv):
    # Get benchmark data (just holding the stock)
    prices = get_data([symbol], pd.date_range(sd, ed), colname='Adj Close')[symbol]
    benchmark = (prices / prices.iloc[0]) * sv
    
    # Get trades from theoretically optimal strategy
    df_trades = testPolicy(symbol=symbol, sd=sd, ed=ed, sv=sv)
    portvals = compute_portvals(df_trades, start_val=sv)

    # Normalize benchmark and portfolio values
    benchmark_normalized = benchmark / benchmark.iloc[0]
    portvals_normalized = portvals['Portfolio Value'] / portvals['Portfolio Value'].iloc[0]
    
    # Plotting the results
    plt.figure(figsize=(12, 6))
    plt.plot(benchmark_normalized, label='Benchmark (Buy and Hold)', color='purple')
    plt.plot(portvals_normalized, label='Theoretically Optimal Portfolio', color='red')
    plt.legend()
    plt.xlabel('Date')
    plt.ylabel('Normalized Value')
    plt.title('Theoretically Optimal Strategy vs. Benchmark')
    plt.grid(True)
    plt.savefig("Theoretically Optimal Strategy vs. Benchmark.png")
    
    # Print statistics
    cum_return_benchmark = (benchmark_normalized.iloc[-1] / benchmark_normalized.iloc[0]) - 1
    cum_return_portfolio = (portvals_normalized.iloc[-1] / portvals_normalized.iloc[0]) - 1
    std_daily_return_benchmark = benchmark.pct_change().std()
    std_daily_return_portfolio = portvals['Portfolio Value'].pct_change().std()
    mean_daily_return_benchmark = benchmark.pct_change().mean()
    mean_daily_return_portfolio = portvals['Portfolio Value'].pct_change().mean()



    print(f"Cumulative return of benchmark: {cum_return_benchmark:.6f}")
    print(f"Cumulative return of portfolio: {cum_return_portfolio:.6f}")
    print(f"Stdev of daily returns of benchmark: {std_daily_return_benchmark:.6f}")
    print(f"Stdev of daily returns of portfolio: {std_daily_return_portfolio:.6f}")
    print(f"Mean of daily returns of benchmark: {mean_daily_return_benchmark:.6f}")
    print(f"Mean of daily returns of portfolio: {mean_daily_return_portfolio:.6f}")

    # Save statistics to CSV
    stats = {
        "Cumulative Return of Benchmark": [f"{cum_return_benchmark:.6f}"],
        "Cumulative Return of Portfolio": [f"{cum_return_portfolio:.6f}"],
        "Stdev of Daily Returns of Benchmark": [f"{std_daily_return_benchmark:.6f}"],
        "Stdev of Daily Returns of Portfolio": [f"{std_daily_return_portfolio:.6f}"],
        "Mean of Daily Returns of Benchmark": [f"{mean_daily_return_benchmark:.6f}"],
        "Mean of Daily Returns of Portfolio": [f"{mean_daily_return_portfolio:.6f}"]
    }
    stats_df = pd.DataFrame(stats)
    stats_df.to_csv("strategy_stats.csv", index=False)
    
